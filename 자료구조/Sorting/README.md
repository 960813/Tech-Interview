# 정렬(Sorting)

| Sorting   | In-Place | Stable | Comparison | Time Complexity |
| --------- | -------- | ------ | ---------- | --------------- |
| Selection | ○        | ×      | ○          | O(n^2)          |
| Bubble    | ○        | ○      | ○          | O(n^2)          |
| Quick     | ○        | ×      | ○          | O(nlogn)        |
| Insertion | ○        | ○      | ○          | O(n^2)          |
| Shell     | ○        | ×      | ○          | O(n^2)          |
| Merge     | ×        | ○      | ○          | O(nlogn)        |
| Radix     | ×        | ○      | ×          | d * O(n)        |
| Heap      | ○        | ×      | ○          | O(nlogn)        |

###### * In-place : 입력 배열 외 추가 메모리 필요 x

###### * stable : 같은 값의 위치가 정렬 과정에서 뒤바뀌지 않음



#### Selection sort

 배열의 맨 앞에서부터 배열을 탐색하여 최솟값(or 최대값)을 찾아서 바꿔 나간다.

 i. 주어진 배열 중에서 최솟값(or 최대값)을 찾는다.

 ii. 그 값을 맨 앞에 위치한 값과 교체한다.

 iii. 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체한다.

 iv. 하나의 원소만 남을 때까지 위의 1~3 과정을 반복한다.

 장점 : 자료 이동 연산 횟수가 미리 결정 된다 = O(n) , 자료의 크기가 큰 정렬에 유리함 

 단점 : 느림. not stable.



#### Bubble sort

정렬되지 않은 전체 자료들을 대상으로 인접한 두 개 자료의 값을 비교 하여 위치를 교환해 정렬한다.

정렬을 1회전 수행할 때마다 정렬에서 제외되는 데이터가 하나씩 늘어난다. (1회전 수행하고 나면 가장 큰 자료가 맨 뒤로 이동하므로 2회전에서는 맨 끝에 있는 자료는 정렬에서 제외됨)

장점 : stable.

단점 : 느림. 이동 연산의 횟수(평균적으로 O(n^2))가 커서 자료의 크기가 클 때는 불리함.



#### Quick sort

Pivot을 기준으로 두 자료의 키 값을 비교하여 위치를 교환해서 정렬한다.

i. 배열에서 pivot을 선택한다

ii. pivot을 기준으로 pivot보다 작은 요소들은 모두 pivot 왼쪽으로 옮기고, pivot보다 큰 요소들은 모두 pivot의 오른쪽으로 옮긴다. 

iii. pivot을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.

- 분할된 부분 리스트에 대하여 순환 호출을 이용하여 정렬을 반복한다.
- 부분 리스트에서도 다시 pivot을 정하고 pivot을 기준으로 2개의 부분 리스트로 나누는 과정 반복

iv. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.

장점 : 빠르다. 추가 메모리 공간 필요하지 않음.

단점 : 정렬된 리스트에 대해서는 퀵 소트의 불균형 분할에 의해 오히려 수행시간이 더 많이 걸린다. 불균형 분할을 방지하기 위해서 pivot 선택 시 리스트의 중간값을 pivot으로 선택한다.



#### Insertion sort

배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입해 정렬을 완성한다.

장점 : 기존에 이미 정렬이 되어 있는 경우 O(n)의 효율성 가짐. stable함. 레코드 수가 적을 경우 알고리즘 자체가 간단하여 유리할 수 있다.

단점 : 모든 원소가 역순으로 되어 있는 최악의 경우나 평균일때 O(n^2) 효율성. 레코드 수가 많고 레코드 크기가 클 경우 적합하지 않다.





#### Shell sort

insertion sorting을 보완한 정렬방법. 기존 자료를 일정한 간격에 의해 여러개의 집합으로 나눈 다음, 각 부분 집합에 대해 insertion sorting을 수행하여 전체 자료를 정렬한다. 

-  정렬해야 할 리스트의 각 k번째 요소를 추출해서 부분 리스트를 만든다. 이때 k를 간격(Gap)이라고 한다.

    k 초기값 : 정렬할 값의 수 / 2

    생성된 부분 리스트의 개수는 gap과 같다.

- 각 회전마다 간격 k를 절반으로 줄인다. 즉 각 회전이 반복될 때마다 하나의 부분 리스트에 속한 값들의 개수는 증가한다

- 간격 k가 1이 될 때 까지 반복

 장점 : 삽입정렬보다 빠름.

 단점 : not stable.



#### Merge sort

같은 개수의 원소를 가지는 부분 집합으로 기존 자료를 분할하고 분할된 각 부분 집합을 merge하면서 정렬 작업을 완성하는 분할정복(divide and conquer) 기법을 이용한 정렬방식. 여러 개의 정렬된 부분집합을 결합하여 정렬된 집합으로 만듬.

장점 : stable. 데이터의 분포에 영향을 덜 받음(입력 데이터가 무엇이든 간에 정렬되는 시간 동일). 배열 대신 연결 리스트로 구성하면 링크 인덱스만 변경되므로 데이터 이동은 무시할 수 있을 정도로 작아짐(in place하게 구현가능). 자료의 크기가 클 경우 연결리스트를 사용하면 어떤 정렬방법보다 효율적.

단점 : 추가 메모리 공간 필요. 자료의 이동 횟수가 많으므로 자료의 크기가 큰 경우 시간적 낭비가 큼.



#### Radix sort

키 값의 자릿수에 따라 자료를 분배하는 방식을 통해 정렬한다. 비교연산이 필요 없으며, 버킷이라고 불리는 자료보관 큐에 자료를 분배하고 다시 이를 꺼내는 연산을 통해 정렬이 이루어진다. 

1의 자리에 대해서 분배 -> 버킷별로 자료들을 꺼냄 -> 10의 자리에 대해서 분배 -> 버킷별로 자료들 꺼냄 

장점 : stable.  빠름.

단점 : 자릿수 개념이 적용 되어야 하므로 보통 숫자 키의 경우에만 적용. 한글과 같은 문자 키인 경우 상당히 많은 버킷이 필요하다. 자료의 분배저장을 위해 버킷 메모리 필요.



#### Heap sort

최대 힙 트리나 최소 힙 트리를 구성해 정렬한다.

내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성한다.

i  정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.

ii. 한번에 하나의 요소를 힙에서 꺼내 배열의 뒤부터 저장

iii. 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.

- max heap 삽입
  1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입.
  2. 새로운 노드를 부모 노드들과 교환해서 힙의 성질 만족
- max heap 삭제
  1. 최대 힙에서 최댓값은 루트 노드 이므로 루트 노드가 삭제됨.
  2. 삭제된 루트 노드에서 힙의 마지막 노드를 가져옴 
  3. 힙을 재구성함

장점 : 우수한 정렬 효율성. heap sort가 가장 유용한 경우는 전체 자료 정렬하는 것이 아니라 가장 큰 값 몇개만 필요할 때.

단점 : not stable.



