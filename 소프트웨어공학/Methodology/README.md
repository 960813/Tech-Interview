# 소프트웨어 개발 방법론

소프트웨어 개발 방법론, Methodology, Method +  Knowlege

### 소프트웨어 공학이란?

일반적으로. 인류의 이익을 위해 소프트웨어와 관련된 원리, 지식, 도구 등을 활용하여 새로운 제품, 도구 등을 만드는 것

학문적으로. 소프트웨어의 개발, 운용, 유지보수 등의 생명 주기 전반을 체계적, 서술적, 정량적으로 다루는 학문

### 소프트웨어 공학이 필요한 이유는?

소프트웨어의 필요성이 증가하게 되면서 더 크고 복잡한 소프트웨어의 요구가 생기고 이를 올바르게 개발하고 안전하게 유지보수하는 체계적인 프로세스가 필요하기 때문

### 소프트웨어 생명 주기 모델

소프트웨어를 기획부터 개발, 폐기까지를 하나의 주기로 보고 이를 효과적으로 관리하기 위한 프로세스를 정의한 것

> 일반적인 개발 단계 : 계획(Planning) > 분석(Analysis) > 설계(Design) > 구현(Implementation) > 유지보수(Maintenance)

> 일반적으로 사용하는 생명주기 모델은 폴포수, 프로토타입, 익스트림 프로그래밍, 나선형 등이 있다.

#### 1. 폭포수 모델 (Waterfall)

**기획 > 분석 > 설계 > 개발 > 테스트 > 유지보수**

![image](https://user-images.githubusercontent.com/42582516/80311830-f3dc8a00-881c-11ea-8408-cba0cd77b93a.png)

1. 기획(계획수립)

   * 타당섬 검토라 한다.
   * 고객의 요구조건, 시스템 환경등을 고려하여 프로젝트 진행 여부를 판단.
   * 진행결정이 나면 프로젝트 전반적인 계획에 들어간다.

2. 분석(요구분석)

   * 사용자의 요구사항을 듣고 정확히 기능적, 비 기능적 요구사항을 도출한다.
   * 요구사항 명세 작성.

3. 설계

   * 요구사항 명세가 전달되면 **요구사항 명세를 준수하는 설계** 에 들어간다.

   * 요구 명세에 따라 소프트웨어의 전체 구조와 구조간의 관계, 상세 알고리즘을 설계 하는데 

     전체 구조를 설계 하는 것은 "기본설계" 상세 알고리즘을 설계하는 것을 "상세 설계"라고 합니다. 

4. 개발/구현

   * **"요구사항 명세를 준수하는"** 설계에 따라 **"요구사항 명세를 준수하는"** 코딩을 통해 소프트웨어를 만들어나갑니다.
   * 이때 단위테스트(Unit Test)와 코드 검증도 함께 진행됨.
   * 이렇게 코딩을 하면서 유닛테스트를 거치기 때문에 이 단계를 **"개발 및 단위테스트 단계"** 라고도 합니다.

5. 테스트

   * 완성된 코드를 정식으로 테스트하여 오류를 발견하는 단계.

   * 테스트 단계

     1. 모듈들을 통합시키며 진행하는 통합테스트(Integration Test)

        * 전체 테스트 느낌.

        * A,B,C 라는 모듈이 있다고 가정 합니다.

          A는 고객 이름을 입력받고, 

          B는 A가 입력받은 내용을 저장하고, 

          C는 저장내용을 다시 출력하는 모듈 입니다.

        * 모듈 하나하나 테스트하는게 Unit test인데 이거다 모아서 입력/저장/출력 다해보는게 통합테스트.

     2. 전체 시스템 동작에 대한 검증을 하는 시스템테스트(System Test)
        * 전체 시스템 동작에 대한 검증을 하는 단계
          1. 암복호화 데이터의 처리 결과 확인.
          2. 데이터의 처리시간을 통해 시스템 속도 측정
          3. 정확한 데이터 처리 확인 및 성공률과 실패율 확인.
          4. 최대 부하, 복구 및 재시동 능력 확인.
     3. 사용자가 현장에서 검증 해보는 인수테스트(Acceptance test)
        * 사용자 요구사항 처리에 대한 검증.
        * 사용자 요구기능을 실행하여 정확히 수행하는지 테스트함.

6. 유지보수

   * 사용자에게 소프트웨어가 인도되는데 그 이후로 주구장창 소프트웨어를 사용하면서 나타나는 오류를 수정하며 계속 고객 요구에 따른 추가기능 개발을 진행하는 과정
   * 유지보수 끝나는상황
     1. 요지보수 계약 종료후 재계약 안할때
     2. 소프트웨어 폐기

**특징**

* 고전적인 라이프 사이클 패러다임
* 가장 오래되고 널리 사용되는 패러다임
* 순차적인 접근 방법
* 하향식 접근방법

**장점** 

* 선형 순차적인 모델로 전체 과정이 이해가 쉽고 관리가 편함
* 프로젝트 진행과정을 세분화하여 관리에 용이
* 고전적인 방법론이라서 적용사례가 풍부하다.
* 문서, 산출물의 관리와 적용이 쉽다.

**단점** 

* 과정이 끝나면 뒤로 돌아가기 어렵기 때문에 초기 요구사항이 완벽해야한다.(그러나 그렇기는 매우 어렵다.)
  * 피드백에 대한 반복단계가 어렵다는말. 이게 엄청 단점이긴하다.
  * 나중에 테스트 단계에 발견된 중요한 결함에 대한 대응또한 어렵다.
* 대규모일 수록 부분 순환이 발생하기 때문에 순차적인 흐름을 따라가는 데 어려움이 있다.
* 결과가 후반부에 가서야 얻어짐으로 중요한 문제점이 뒤에 발견된다.
* 병행작업이 안된다.
* 고객 요구사항에 대한 상세한 반영이 어렵다.



#### 2. 원형(Prototyping) 패러다임

![image](https://user-images.githubusercontent.com/42582516/80311847-0bb40e00-881d-11ea-865c-f1670bc8ba6b.png)

![image](https://user-images.githubusercontent.com/42582516/80311855-1373b280-881d-11ea-9231-02102f33c316.png)

**특징**

* 목표를 정하였으나 속성을 어떻게 만속시킬지 모르는 경우
* 사용자의 요구사항이 무엇인지, 요구를 어떻게 변경될지 구체적으로 모르는 경우
* 개발자들이 고객의 요구를 불완정하게 이해하는 경우
* 요구사항을 명세화하기 어려울 경우

다음과 같은 상황에서 사용한다.

**장점**

* 개발 초기에 미리 결과물을 확인할 수 있어서 사용자의 이해를 도움
* 개발의 초기 단계에서 수정 / 보완 사항을 미리 파악 가능
* 분석 및 설계 과정에서 사용자가 동참하기 즉각적인 피드백을 줄 수 없음

**단점**

* 일회적 프로젝트나 대규모 프로젝트의 개발에는 적용하기 쉽지 않음
* 불완정한 요구사항을 바탕으로 시제품이 만들기 때문에 결과적으로 불완전한 시스템을 산출하여 수정과 보완에 많은 인력과 시간이 투입
* 완료된 프로토타입을 이용하여 시스템을 구현했는데 원하는 시스템이 아닌 경우 재작업 실시



#### 3. 나선형 패러다임

각 나선은 4단계로 나눠진다.
: 계획 및 정의 단계 > 위험 분석 단계 > 개발 단계 > 고객 평가 단계

![image](https://user-images.githubusercontent.com/42582516/80311873-25555580-881d-11ea-9e8b-4130ef89284a.png)

**특징**

* 폭포수 모델과 원형 패러다임의 장점에 새로운 요소인 위험 분석을 추가하여 만듦
  **높은 위험도인 경우 사용**, 위험 분석을 진행함
* 위험을 관리하고 최소화하려는 것이 이 패러다임의 주 목적
* 나선을 돌면서 점진적으로 완벽한 시스템 개발

**장점**

* 비용이 많이 들고 시간이 오래 걸리는 대형 시스템구축(대형사업)에 가장 현실적인 접근 방법 성과를 보며 위험 부담을 줄일 수 있는 방법

**단점**

* 모델자체가 복잡하여 프로젝트 관리가 어려움, 상업용 제품에는 이 방법보단 프로토타입이 적합



#### 4. 4세대 기법

* 요구사항 명세서로부터 실행코드를 자동으로 생성할 수 있게 해주는 방법
* 현재 4GT 도구들은 자연언어를 실행코드로 바꾸어 줄 만큼 정교하지 못한다.
* 형식 규격 언어로 표현하려는 노력(ex. EER(Enahanced Entity-Relationship) 모델로 만들어진 명세서에서 데이터베이스의 코드가 생성)



#### 5. 애자일(Agile) 방법

**기존 방법론**은 프로젝트의 본질적인 목표보다 계획 수립, 문서화, 품질 관리 등 부수적으로 수행되는 작업이 **오버헤드(overhead) 비용**을 발생시킨다.

1990년대 민첩성과 실용성을 앞세운 가벼운 경량급 개발 방법론인 애자일 기법을 제안

![image](https://user-images.githubusercontent.com/42582516/80311928-6483a680-881d-11ea-8139-dbd2d6c055da.png)

**특징**

* 기술적 부채 해결
* 리팩토링 활용
* 객체지향 기법의 적용

**장점**

* 빠른 프로토타입과 짧은 릴리즈 → 소프트웨어 개발 성공률을 높일 수 있음
* 작은 프로젝트부터 쉽게 도입 → 비용과 위험도도 상대적으로 낮다
* 점진적으로 테스트 할 수 있어서 버그를 더 빠르게 발견할 수 있다.
* 수정과 변경에 유연하다.
* 프로젝트를 시작할때 계획단계에 버리는 시간을 줄일 수 있다.

**단점**

* 성공사례가 많지 않음 → 개발자와 고객이 함께 협업
  사용자 스토리를 작성, 테스트케이스를 작성, 자원을 추정, 릴리즈 계획의 수립
* 참여와 소통, 개인의 성숙도, 상호협력이 중요
* 개발 프로세스 및 소프트웨어 공학에 관한 수준 높은 기술이 필요

"**애자일 소프트웨어 개발을 위한 선언문**"에서

> 프로세스 자체보다 팀원 간 상호 작용, 문서보다 동작하는 소프트웨어, 계약과 협상보다 고객과의 협력, 계획의 준수보다 변화에 민첩한 대응에 더 큰 가치를 둔다는 것이다. 이는 계획의 완수가 아니라 고객에게 전달할 가치를 중시한다는 의미다.

**고객 중심 / 아웃풋 중심 / 유연하고 민첩한 대응력 / 자율성과 권한을 가진 조직 운영**



#### 5.1 익스트림 프로그래밍(XP)

XP는 애자일 소프트웨어 개발 방법론 중 가장 많이 알려진 방법

XP는 **의사소통, 단순함, 피드백, 용기, 존중** 등 5가지의 가치에 시초

XP는 **개발 속도를 높이는 가속 기술**이며, 그 중심은 단순한 **디자인 정신**, **테스트 우선 프로그래밍**, **리팩토링**이라 할 수 있다.

* 사용자 스토리(user story) : 고객이 원하는 기능을 짧게 표현해 놓은 것
  * 고객과 직접 상의하고 작성한다.
  * 간략한 설명이나 키워드를 포함하는 짧은 문장
  * 스토리 작성은 다음을 가정한다.
    * 요구사항은 변할 수 있고 정확히 알지 못할 수 있다.
  * 사용자와 개발자가 지속적으로 대화해야한다.
  * ![image](https://user-images.githubusercontent.com/42582516/80311885-31d9ae00-881d-11ea-8f7d-7c2f2168af8e.png)
  * ![image](https://user-images.githubusercontent.com/42582516/80311887-33a37180-881d-11ea-888a-ea250bfee6df.png)
* 좋은 사용자 스토리
  * 독립적이다.
  * 협상 가능하다.
  * 사용자와 고객에게 가치가  있다
  * 추정 가능하다
  * 작다
  * 테스트 가능해야 한다.



### References

* https://ikso2000.tistory.com/53
* [https://velog.io/@rxjw95/%EA%B8%B0%EC%88%A0-%EB%A9%B4%EC%A0%91Software-Engineering](https://velog.io/@rxjw95/기술-면접Software-Engineering)
* https://storyofsol.tistory.com/124
* https://m.blog.naver.com/PostView.nhn?blogId=seilius&logNo=130185585600&proxyReferer=https:%2F%2Fwww.google.com%2F

