### 비교하지 않고 정렬가능한 알고리즘들

- Counting Sort
- Raidx Sort

### 소개

Counting Sort는 O(n)의 시간복잡도를 가진다. 이는 quick sort의 평균 시간복잡도 O(nlogn) 보다 빠르다. 그런데 대부분의 정렬에서 Quick Sort를 쓰는 이유는?

###### A : 5,5,3,4,5,1,0,4,1,3,0,2,4,2,3,0

인 A가 있다. A를 정렬하면 B를 얻는다

 ###### B : 0,0,0,1,1,2,2,3,3,3,4,4,4,5,5,5



### Step1. 숫자와 등장횟수를 세어준다.

| 숫자      |  0   |  1   |  2   |  3   |  4   |  5   |
| :-------- | :--: | :--: | :--: | :--: | :--: | :--: |
| 등장 횟수 |  3   |  2   |  2   |  3   |  3   |  3   |

### Step2. 등장 횟수를 누적합으로 바꿔줍니다.

| 숫자    |   0   |    1    |     2     |      3       |       4        |        5         |
| :------ | :---: | :-----: | :-------: | :----------: | :------------: | :--------------: |
| 누적 합 | 3 (3) | 5 (3+2) | 7 (3+2+2) | 10 (3+2+2+3) | 13 (3+2+2+3+3) | 16 (3+2+2+3+3+3) |

의미 : '1부터 시작하는 인덱스를 가진 배열'에 값을 정렬해 넣으면 위의 표에 있는 값이 가장 오른쪽에 있는 값이다(밑에 그림 참고)

### Step3. 뒤에서 부터 넣어주면서, 누적합을 빼주자

![img](https://t1.daumcdn.net/cfile/tistory/22538A4D56D2FFBA2E)



![img](https://t1.daumcdn.net/cfile/tistory/234A764D56D2FFBF38)

![img](https://t1.daumcdn.net/cfile/tistory/27686D4D56D2FFC117)

![img](https://t1.daumcdn.net/cfile/tistory/225C7D4D56D2FFC223)



![img](https://t1.daumcdn.net/cfile/tistory/23057D4956D2FFE314)



### 정리 : 그래서 퀵소트를 대신하지 못하는 이유가?

`Counting Sort` 알고리즘의 시간복잡도는 O(n) 으로 `Quick Sort`보다 훨씬 유리해보입니다. 그러나 `세상에 공짜는 없다`는 말처럼 `Counting Sort`는 대부분의 상황에서 엄청난 `메모리 낭비`를 야기할 수 있습니다.

###### 배열에 있는 값이 [0, 2, 0, 100, 2, 0] 이면 누적합을 계산하기 위해서 누적합 배열을 100으로 잡아야함. 만약 최대값이 10억이면, 10억짜리 누적합 배열을 잡아야 함.

--> 정리 : 5,5,3,4,5,1 처럼 특정한 범위(1~5)에 있는 수를 정렬할 때는 매우 유용한 정렬법이다.

--> 하지만, 매우 큰 수가 끼어있다면 메모리 효율이 심각하게 나빠져서 퀵소트를 대신하지는 못한다.



### **기수정렬 (Radix Sort)**

- 기수정렬은 낮은 자리수부터 비교하여 정렬해 간다는 것을 기본 개념으로 하는 정렬 알고리즘입니다. 

- 기수정렬은 비교 연산을 하지 않으며 정렬 속도가 빠르지만 데이터 전체 크기에 **기수 테이블의 크기만한 메모리**가 더 필요합니다.

--> Count Sort와 같이, 빠른 정렬속도 but 낮은 메모리 효율

##### 기수 테이블의 크기만한 메모리 ??

숫자를 정렬 할 거면 10개의 추가 메모리, 알파벳을 정렬할 거면 26개의 추가 메모리가 필요함을 의미

### Step 1. 추가적인 메모리 확보

![img](https://t1.daumcdn.net/cfile/tistory/99A6D33359CE331015)

### Step 2. 가장 낮은 수 부터 메모리에 넣음

![img](https://t1.daumcdn.net/cfile/tistory/9957483359CE33AB14)

### Step 3. 메모리에서 꺼낸후, 그 다음으로 낮은 수를 기준으로 메모리에 넣음. (2~3반복)

 ![img](https://t1.daumcdn.net/cfile/tistory/990D3A3359CE34472B)

![img](https://t1.daumcdn.net/cfile/tistory/9913633359CE34C223)

### Step 4. 마지막으로 꺼내면 정렬 완료

![img](https://t1.daumcdn.net/cfile/tistory/99C8DB3359CE35D412)



### Radix와 Count의 공통점

- 빠른 속도, 낮은 메모리 효율
- 둘 다 Stable하다

