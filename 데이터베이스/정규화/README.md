# 정규화

## 정규화란? 

데이터베이스의 설계를 재구성하는 테크닉. 정규화를 통해 불필요한 데이터(redundancy)를 없앨 수 있고, 삽입/갱신/삭제 시 발생할. 수 있는 각종 이상현상들을 방지할 수 있습니다.

정규화란 데이터베이스에서 **중복을 최소화하기 위해 데이터를 구조화하는 작업이다.** 좀 더 구체적으로는 불만족스러운 나쁜 릴레이션의 애트리뷰트들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 말한다. 정규화 과정을 거치게 되면 정규형을 만족하게 된다. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제2 정규형, 제 3 정규형 등이 존재한다.

**함수적 종속성이란** 함수적 종속성이란 애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호관계로부터 유도되는 제약조건의 일종이다. X와 Y를 임의의 애트리뷰트 집합이라고 할 때, **X의 값이 Y의 값을 유일하게 결정한다면 "X는 Y를 함수적으로 결정한다"** 라고 한다. 함수적 종속성은 실세계에서 존재하는 애트리뷰트들 사이의 제약조건으로부터 유도된다. 또한 각종 추론 규칙에 따라서 애트리뷰트들간의 함수적 종속성을 판단할 수 있다.

## 목적

데이터 베이스 정규화의 목적은 주로 두가지 입니다.

1. 불필요한 데이터(data redundancy)를 제거한다.
2. 데이터 저장을 **"논리적으로"** 한다.



## 1NF (제 1 정규형)

> 모든 도메인이 원자값(Atomic Value)만으로 구성되도록 하는 정규형을 말한다.
> 각 칼럼은 atomic해야한다.

테이블이 제 1NF를 만족했다는 것은 아래 세가지 조건을 만족했다는 것을 의미한다.

1. 어떤 Relation에 속한 모든 Domain이 원자값(atomic value) 만으로 되어있다.
2. 모든 attribute에 반복되는 그룹(repeating group)이 나타나지 않는다.
3. 기본 키를 사용하여 관련 데이터의 각 집합을 고유하게 식별할 수 있어야 한다.

#### Ex. 

| **STUDENT_ID** |          **COURSE_ID**          |   GRADE   | STUDENT_NM |
| :------------: | :-----------------------------: | :-------: | :--------: |
|    20800399    | CSE011101, CSE022202, CSE033303 | A+, A, B+ |     야     |

위 형태의 릴레이션은 제 1정규형을 만족하지 않는다. 

| **STUDENT_ID** | **COURSE_ID** | GRADE | STUDENT_NM |
| :------------: | :-----------: | :---: | :--------: |
|    20800399    |   CSE011101   |  A+   |    야붕    |
|    20800399    |   CSE022202   |   A   |    야붕    |
|    20800399    |   CSE033303   |  B+   |    야붕    |

다음과 같이 고치면 된다.

> 1NF 예시.



## 2NF (제 2 정규형)

> 1NF & 각 nonprime 칼럼은 (각 key에 full FD)해야한다.

제 2 정규화를 수행했을 경우 테이블의 모든 컬럼이 완전 함수적 종속을 만족한다.(부분 함수적 종속을 모두 제거되었다.) 이를 이해하기 위해서는 **부분 함수적 종속** 과 **완전 함수적 종속** 이라는 용어를 알아야 한다.

* 함수적 종속 (Functional Dependency) : X의 값에 따라 Y값이 결정될 때 X->Y로 표현하는데, Y는 X에 대해 **함수적 종속** 이라고 한다. 예를 들어 학번을 알면 이름을 알 수 있는데, 이경우엔 학번이 X가 되고 이름이 Y가 된다. X를 결정자라하고 Y는 종속자라고 한다. 
* 함수적 종속에서 X의 값이 여러 요소 일경우, 즉, {X1, X2} -> Y일 경우, X1와 X2가 Y의 값을 결정할 때 이를 **완전 함수적 종속** 이라고 하고 ,X1, X2 중 하나만 Y의 값을 결정할 때 이를 **부분 함수적 종속** 이라고 한다.

#### Ex.

| **학번** | **과목코드** | 성적 |     학부     | 등록금 |
| :------: | :----------: | :--: | :----------: | :----: |
| 20800399 |  CSE011101   |  A+  | 컴퓨터공학부 |  350   |
| 20800399 |  CSE022202   |  A   | 컴퓨터공학부 |  350   |
| 20800399 |  CSE033303   |  B+  | 컴퓨터공학부 |  350   |
| 21300758 |  MEC011101   |  F   |   경영학부   |  300   |
| 21400001 |  POD032939   |  C+  |  기계공학부  |  400   |
| 21500399 |  CSE011101   |  D   | 컴퓨터공학부 |  350   |

위 릴레이션의 함수적 종속성을 살펴보면 아래와 같다.

> {학번, 과목코드} -> 성적
> {학번, 과목코드} -> 학부
> {학번, 과목코드} -> 등록금
> 학번 -> 학부
> 학번 -> 등록금
> 학부 -> 등록금

현재 학번->학부, 학번->등록금 두개의 부분 함수 종속성을 가지고 있다. 이를 제거해 주는 것을 제2정규화라고 한다.

**학생 릴레이션**

| **학번** |     학부     | 등록금 |
| :------: | :----------: | :----: |
| 20800399 | 컴퓨터공학부 |  350   |
| 21300758 |   경영학부   |  300   |
| 21400001 |  기계공학부  |  400   |
| 21500399 | 컴퓨터공학부 |  350   |

**성적 릴레이션**

| **학번** | **과목코드** | 성적 |
| :------: | :----------: | :--: |
| 20800399 |  CSE011101   |  A+  |
| 20800399 |  CSE022202   |  A   |
| 20800399 |  CSE033303   |  B+  |
| 21300758 |  MEC011101   |  F   |
| 21400001 |  POD032939   |  C+  |
| 21500399 |  CSE011101   |  D   |

> 2NF 예시.



## 3NF (제 3 정규형)

> 1NF & 각 nonprime 칼럼은 ((각 key에 fully FD)&&(비 key에 dependent하지 않아야))한다.
>
> 쉽게말해서 제 1, 2 정규형을 만족하고 **이행적 함수 종속관계** 를 갖지 않는것.

테이블(Relation)이 제 3 정규형을 만족한다는 것은 아래 두 가지조근을 만족하는 것을 의미한다.

1. Relation이 제 2 정규화 되었다. 
2. 기본 키(primary key)가 아닌 속성(Attribute)들은 기본 키 에만 의존해야

지금 학생 릴레이션에서 함수적 종속성은 아래와 같다.

> 학번 -> 학부
> 학부 -> 등록금
> 학번 -> 등록금

*X->Y, Y->Z 함수적 종속관계로 인해 X->Z 의 이행적 함수 종속 관계가 나타나면 [X, Y], [Y, Z] 두 릴레이션으로 분해한다.*

![img](https://s3.ap-northeast-2.amazonaws.com/yaboong-blog-static-resources/etc/relation-student-and-department.png)

> 3NF 예시.



## BCNF 정규형

> 1NF & 각 칼럼은 ((각 key에 fully FD)&& (비 key에 dependent 하지 않아야))한다.
>
> 모든 결정자가 키인 경우 BCNF.

> X -> Y 는 trivial FD 이거나, X 는 릴레이션 R 의 슈퍼키이다.

Trivial FD 는 Y 가 X 의 부분집합인 경우를 말한다. A->A 이거나 AB->A 같은 당연한 경우를 말하는 것이다. 그래서 BCNF 에 대한 정의를 실용적인 말로 바꾸면 "모든 결정자가 KEY 인 경우 **BCNF** 이다" 라고 할 수 있겠다. BCNF 를 위반하는 릴레이션은 이론적으로는 아래와 같은 구조를 가지게 된다. (A, B 가 키)

<img width="887" alt="image" src="https://user-images.githubusercontent.com/36303777/80274140-36b23b00-8713-11ea-94e5-634108d87883.png">

위의 사진은  BCNF를 위반하는 경우이다.

#### BCNF를 위반하는 사례

![img](https://s3.ap-northeast-2.amazonaws.com/yaboong-blog-static-resources/etc/bcnf-violation-ex.png)

### 분해

BCNF 를 위반하는 릴레이션에 대한 분해과정은 아래와 같다.

- BCNF 를 위반하는 nontrivial FD X -> Y 를 찾는다.
- 두 개의 릴레이션으로 분해한다.
  - XY 로 구성된 릴레이션 하나
  - X 와 나머지 속성들로 구성된 릴레이션 하나

위 과정을 Student, Course, Instructor 예제에 적용시키면 아래와 같다.

- nontrivial FD Instructor -> Course 를 찾았다.
- 두 개의 릴레이션으로 분해한다.
  - Instructor, Course 하나
  - Instructor 와 나머지 속성들로 구성된 릴레이션 Instructor, Student

분해한 두 개의 릴레이션에서 기존 릴레이션에서 결정자역할을 했던 속성을 키로 해준다. 그러면 BCNF 까지 만족시키는 릴레이션 두 개가 생기게 된다.

![img](https://s3.ap-northeast-2.amazonaws.com/yaboong-blog-static-resources/etc/bcnf-violation-resolved.png)BCNF를 만족하는 두개의 릴레이션으로 분해



> BCNF 예시.



### Reference

* https://wkdtjsgur100.github.io/database-normalization/
* https://yaboong.github.io/database/2018/03/10/database-normalization-2/