# Graph

##### 객체 사이의 연결 관계를 표현하는 자료구조



####  노드(Node 혹은 정점 Vertex)와 간선(Edge)의 집합 (G = V + E)

- 노드 : 모델링하려는 시스템을 구성하는 객체를 나타냄

- 간선 : 객체 사이의 관계를 정의

  

#### 간선(Edge)의 특성에 따른 그래프 종류

- ##### 무방향 그래프(Undirected Graph)

  두 노드를 연결하는 간선에 방향이 없는 그래프

- ##### 방향 그래프(Directed Graph)

   두 노드를 연결하는 간선에 방향이 있는 그래프 

- ##### 가중 그래프(Weigthed Graph)

  연결하는 간선에 가중치가 할당된 그래프

  

#### 구조적 특성에 따른 그래프 종류

- ##### 완전 그래프(Complete Graph)

  그래프 내의 모든 노드가 1:1 간선으로 연결된 경우. 연결 가능한 최대 간선 수를 가진 그래프

- ##### 부분 그래프(Sub Graph)

  원래의 그래프에서 일부의 노드나 간선을 제외하여 만든 그래프

- ##### 다중 그래프(Multi Graph)

  중복된 간선을 포함하는 그래프

  

#### 그래프 관련 용어

- ##### 인접(Adjacent)

  두 개의 노드를 연결하는 간선이 존재하는 경우 두 노드는 인접되었다고 함

- ##### 부속(Incident)

  두 개의 노드를 연결하는 간선이 존재하는 경우 이 간선은 두 노드에 각각 부속되었다고 함

- ##### 차수(Degree)

  노드에 부속된(연결된) 간선의 개수를 차수(degree)라고 함

  

#### 그래프 구현

- ##### 인접 행렬 이용

  - 인접한 Vertex들에 관한 데이터를 2차원 배열로 저장
  - 각 Vertex 사이의 Edge가 있을 때는 해당 배열의 값이 1이고 없을 때는 값이 0
  - 서로 대칭인 배열의 값이 같은 행렬로 표현된 그래프는 무방향 그래프이다 (무방향 그래프의 대칭성)
  - 방향 그래프는 대칭성이 없음
  - Edge 정보를 2차원 배열로 저장하기 때문에 Vertex의 개수가 n개라고 하면 크기가 n^2인 메모리가 필요. 인접 행렬의 메모리 사용량은 Edge의 개수와 상관이 없으므로 Vertex 개수가 많고 Edge의 개수가 상대 적으로 적을 때는 인접 리스트를 사용하는 것이 바람직함

- ##### 인접 리스트 이용

  - 정점별 인접 정점을 연결 리스트로 저장. 특정 노드에 연결되는 노드를 저장하는 방식
  
  - 장점 : 메모리 절약 가능
  
    인접 행렬을 노드 사이의 연결 여부와 상관없이 모든 간선의 정보를 2차원 배열에 저장하는데에 비해 인접 리스트는 실제 연결된 노드만을 저장하기 때문. 희소 그래프(Sparse Graph, 그래프 내에 적은 숫자의 간선만 가지는 그래프)를 나타내는 경우에 효과가 극대화됨.
  
  - 단점 
  
    1. 구현 복잡성 증가
  
    2. 희소 그래프가 아닌 경우에 인접 행렬보다 메모리 효율성이 떨어짐
  
       인접 행렬의 원소 대부분이 0이 아닌 값이 된다면, 메모리를 낭비하는 부분이 감소함. 연결 리스트는 노드 사이의 포인터 정보 등을 저장해야 하기 때문에 추가적인 메모리가 필요함.
  
    3. 간선에 대한 접근 시간이 더 소요됨
  
       인접 행렬의 경우 배열을 통해 바로 접근 할 수 있었지만, 연결 리스트로 저장한 경우에는 해당 간선에 접근하려면 연결 리스트의 순회가 필요하기 때문에 접근 시간이 더 소요됨. 노드의 개수를 n개라고 했을 때, 인접 행렬에서는 특정 간선에 대한 접근이 O(1)의 시간 복잡도를 가졌다면, 인접 리스트에서는 평균 O(n)의 시간 복잡도를 가짐.
  
  

#### 그래프 탐색

​	간선을 이용하여 그래프 상의 모든 노드를 한번씩 방문하는 것

- ##### 깊이 우선 탐색(DFS, Depth-First Search)

  - 현재 선택된 노드와 연결될 노드 중 아직 탐색되지 않은 노드를 먼저 선택하는 방법. 

  - ~~~c++
    dfs(node v){
      v <- 방문
       for( all u in v의 인접 노드들){
         if( u != 방문){
           dfs(u);
         }
       }
    }
    ~~~

  - 구현 : Stack이용

  - Time Complexity : O(V+E)

- ##### 넓이 우선 탐색(BFS, Breadth-First Search)

  - 현재 선택된 노드의 이전 노드에 연결된 모든 노드가 탐색되도록 탐색
  - 구현 : Queue이용
  - Time Complexity : O(V+E)
  - BFS로 구한 경로는 최단 경로

  

#### 신장 트리와 최소 비용 신장 트리

- ##### 신장 트리(Spanning Tree)

  - 기존 그래프가 가진 모든 노드 V를 순환 없이 서로 연결 시킨 트리
  - 그래프 탐색을 이용하여 생성 할 수 있음

- ##### 최소 비용 신장 트리(Minimum Spanning Tree)

  - 가중 그래프의 신장 트리 중 가중치의 합이 최소인 신장 트리

  - 구하는 방법

    1. Kruskal 알고리즘

       그래프의 모든 간선을 weight 순으로 정렬 한 다음, 낮은 비용을 가지는 간선을 차례대로 선택하여 신장 트리를 완성.

       - 초기화

         (1) edge 없이 vertex 들로만 그래프를 구성

         (2) 그래프 G의 edge를 weight 값에 따라 오름차순으로 정렬

       - 루프

         정렬된 edge들 중에서 (1) 가장 weight가 작고 (2) 순환을 발생시키지 않는 edge를 선택

         그래프 G의 모든 vertex가 연결될 때 까지 반복

       - Time Complexity : O(E logE)

    2. Prim 알고리즘

       트리를 확장시켜 최소 신장 트리를 만듬. 임의의 시작 노드 1개만 추가하여 현재 신장 트리와 연결될 간선 중에서 가장 적은 weight를 가지는 간선을 선택해서 완성.

       - 초기화

         그래프 G에서 임의의 시작 노드 r을 선택 

         V(T) = {r}

       - 루프

         V(T)와 연결된 모든 간선들 중에서 (1) 가장 weight가 작고 (2) 순환을 발생시키지 않는 간선을 선택

         그래프 G의 모든 노드가 V(T)에 포함될 때까지 반복

       - Time Complexity : O(E logV)



