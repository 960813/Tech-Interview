# Graph

##### 객체 사이의 연결 관계를 표현하는 자료구조



####  노드(Node 혹은 정점 Vertex)와 간선(Edge)의 집합 (G = V + E)

- 노드 : 모델링하려는 시스템을 구성하는 객체를 나타냄
- 간선 : 객체 사이의 관계를 정의



#### 간선(Edge)의 특성에 따른 그래프 종류

- ##### 무방향 그래프(Undirected Graph)

  두 노드를 연결하는 간선에 방향이 없는 그래프

- ##### 방향 그래프(Directed Graph)

   두 노드를 연결하는 간선에 방향이 있는 그래프 

- ##### 가중 그래프(Weigthed Graph)

  연결하는 간선에 가중치가 할당된 그래프

  

#### 구조적 특성에 따른 그래프 종류

- ##### 완전 그래프(Complete Graph)

  그래프 내의 모든 노드가 1:1 간선으로 연결된 경우. 연결 가능한 최대 간선 수를 가진 그래프

- ##### 부분 그래프(Sub Graph)

  원래의 그래프에서 일부의 노드나 간선을 제외하여 만든 그래프

- ##### 다중 그래프(Multi Graph)

  중복된 간선을 포함하는 그래프

- ##### 무방향 그래프(Undirected Graph)

  방향이 없는 그래프, (A,B)와 (B,A)는 동일하다.

- ##### 방향 그래프(Directed Graph)

  간선에 방향성이 존재하는 그래프. <A,B>와 <B,A>는 다르다.

- ##### 가중치 그래프(Weighted Graph)

  간선에 비용이나 가중치가 할당된 그래프.

#### 그래프 관련 용어

- ##### 인접(Adjacent)

  두 개의 노드를 연결하는 간선이 존재하는 경우 두 노드는 인접되었다고 함

- ##### 부속(Incident)

  두 개의 노드를 연결하는 간선이 존재하는 경우 이 간선은 두 노드에 각각 부속되었다고 함

- ##### 차수(Degree)

  노드에 부속된(연결된) 간선의 개수를 차수(degree)라고 함

  * In-degree (진입 차수) : 방향 그래프에서 외부에서 오는 간선의 수.
  * Out-degree (진출 차수) : 방향 그래프에서 외부로 향하는 간선의 수.
  
- 경로 길이 (path length) : 경로를 구성한즌 데 사용된 간선의 수.

- 단순 경로 (simple path) : 경로 중에서 반복되는 정점이 없는 경우.

- 사이클 (Cycle) : 단순 경로의 시작 정점과 종료 정점이 동일한 경우.



#### 그래프 구현

- ##### 인접 행렬 이용

  - 인접한 Vertex들에 관한 데이터를 2차원 배열로 저장
  - 각 Vertex 사이의 Edge가 있을 때는 해당 배열의 값이 1이고 없을 때는 값이 0
  - 서로 대칭인 배열의 값이 같은 행렬로 표현된 그래프는 무방향 그래프이다 (무방향 그래프의 대칭성)
  - 방향 그래프는 대칭성이 없음
  - Edge 정보를 2차원 배열로 저장하기 때문에 Vertex의 개수가 n개라고 하면 크기가 n^2인 메모리가 필요. 인접 행렬의 메모리 사용량은 Edge의 개수와 상관이 없으므로 Vertex 개수가 많고 Edge의 개수가 상대 적으로 적을 때는 인접 리스트를 사용하는 것이 바람직함

- ##### 인접 리스트 이용

  - 정점별 인접 정점을 연결 리스트로 저장. 특정 노드에 연결되는 노드를 저장하는 방식
  
  - 장점 : 메모리 절약 가능
  
    인접 행렬을 노드 사이의 연결 여부와 상관없이 모든 간선의 정보를 2차원 배열에 저장하는데에 비해 인접 리스트는 실제 연결된 노드만을 저장하기 때문. 희소 그래프(Sparse Graph, 그래프 내에 적은 숫자의 간선만 가지는 그래프)를 나타내는 경우에 효과가 극대화됨.
  
  - 단점 
  
    1. 구현 복잡성 증가
  
    2. 희소 그래프가 아닌 경우에 인접 행렬보다 메모리 효율성이 떨어짐
  
       인접 행렬의 원소 대부분이 0이 아닌 값이 된다면, 메모리를 낭비하는 부분이 감소함. 연결 리스트는 노드 사이의 포인터 정보 등을 저장해야 하기 때문에 추가적인 메모리가 필요함.
  
    3. 간선에 대한 접근 시간이 더 소요됨
  
       인접 행렬의 경우 배열을 통해 바로 접근 할 수 있었지만, 연결 리스트로 저장한 경우에는 해당 간선에 접근하려면 연결 리스트의 순회가 필요하기 때문에 접근 시간이 더 소요됨. 노드의 개수를 n개라고 했을 때, 인접 행렬에서는 특정 간선에 대한 접근이 O(1)의 시간 복잡도를 가졌다면, 인접 리스트에서는 평균 O(n)의 시간 복잡도를 가짐.
  
  

#### 그래프 탐색

​	간선을 이용하여 그래프 상의 모든 노드를 한번씩 방문하는 것

- ##### 깊이 우선 탐색(DFS, Depth-First Search)

  - 현재 선택된 노드와 연결될 노드 중 아직 탐색되지 않은 노드를 먼저 선택하는 방법. 

  - ~~~c++
    dfs(node v){
      v <- 방문
       for( all u in v의 인접 노드들){
         if( u != 방문){
           dfs(u);
         }
       }
    }
    ~~~

  - 구현 : Stack이용

  - Time Complexity : O(V+E)

- ##### 넓이 우선 탐색(BFS, Breadth-First Search)

  - 현재 선택된 노드의 이전 노드에 연결된 모든 노드가 탐색되도록 탐색
  - 구현 : Queue이용
  - Time Complexity : O(V+E)
  - BFS로 구한 경로는 최단 경로

  

#### 신장 트리와 최소 비용 신장 트리

- ##### 신장 트리(Spanning Tree)

  - 기존 그래프가 가진 모든 노드 V를 순환 없이 서로 연결 시킨 트리
    - 기존 그래프의 모든 노드를 가지고 있고 모든노드가 연결되어있으면서 트리의 속성을 만족하는 그래프.
  - 그래프 탐색(DFS,BFS)을 이용하여 생성 할 수 있음

- ##### 최소 비용 신장 트리(Minimum Spanning Tree)

  - 가중 그래프의 신장 트리 중 가중치의 합이 최소인 신장 트리

  - 구하는 방법

    1. Kruskal 알고리즘

       그래프의 모든 간선을 weight 순으로 정렬 한 다음, 낮은 비용을 가지는 간선을 차례대로 선택하여 신장 트리를 완성.

       - 초기화

         (1) edge 없이 vertex 들로만 그래프를 구성

         (2) 그래프 G의 edge를 weight 값에 따라 오름차순으로 정렬

       - 루프

         정렬된 edge들 중에서 (1) 가장 weight가 작고 (2) 순환을 발생시키지 않는 edge를 선택

         그래프 G의 모든 vertex가 연결될 때 까지 반복

       - Time Complexity : O(E logE)

    2. Prim 알고리즘

       트리를 확장시켜 최소 신장 트리를 만듬. 임의의 시작 노드 1개만 추가하여 현재 신장 트리와 연결될 간선 중에서 가장 적은 weight를 가지는 간선을 선택해서 완성.

       - 초기화

         그래프 G에서 임의의 시작 노드 r을 선택 

         V(T) = {r}

       - 루프

         V(T)와 연결된 모든 간선들 중에서 (1) 가장 weight가 작고 (2) 순환을 발생시키지 않는 간선을 선택

         그래프 G의 모든 노드가 V(T)에 포함될 때까지 반복

       - Time Complexity : O(E logV)

#### 이중 연결 요소(Biconnected Component)

* Biconnected Graph

![image-20200415161631949](/Users/dongwook/Library/Application Support/typora-user-images/image-20200415161631949.png)

속한 노드 한개를 지워도(이때 인접한 간선도 같이 지운다) 다른 남아있는 노드들이 다 연결되어 있는 그래프.

또다른 정의 : 단절점(articulation points)가 없는 Connected Graph

* 단절점(Articulation point) : 하나의 컴포넌트로 이루어진 무방향 그래프에서 한 정점을 제거했을 때 두개 이상의 컴포넌트로 나누어지는 정점.

  ![image-20200415161528994](/Users/dongwook/Library/Application Support/typora-user-images/image-20200415161528994.png)

  여기서 1,3,5,7이 단절점이다.



#### 최단 경로

그래프 사이에서 두 노드 사이의 가장 짧은 경로를 찾는 문제

* BFS 
  * 간선에 가중치가 부여되지 않은 그래프상에서 최단거리를 구할때 사용한다.
  * 시간복잡도 : O(|V|+|E|)O(|V|+|E|). 여기서 |V|는 노드개수 |E|는 간선개수

* Dijkstra

  * ```
    currentDistance = min(currentDistance,nextDistance+cost(current,next)) 
    ```

    

  * 시작노드를 기준으로 다른 모든 노드 사이의 거리를 계산하는 알고리즘.

  * 시작노드에서 시작해서 최단 거리가 짧은 노드를 차례로 선택하여 거리를 계산한다.(Greedy)

  * 동작과정

    1. 아직 선택되지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택한다.
    2. 1번에서 선택된 노드와 연결된 다른 노드의 최단거리를 갱신한다.
    3. 아직 선택되지 않은 노드가 남아있으면 1번으로 돌아간다.

  * 문제점 : 음수의 가중치를 가지는 간선이 존재할경우 사용할 수 없다.

  * 시간복잡도는 짧은 거리를 어떻게 선택하냐에 따라 달라진다.

* Bellman-Ford Algorithm

  * ```
    currentDistance = min(currentDistance,nextDistance+cost(current,next)) 
    ```

  * 다익스트라와 사용하는 식은 같다.

  * 최단경로가 모든 노드를 방문할경우 최대 N-1개의 간선으로 이루어져 있다는 점을 이용한다.

  * 과정

    1. 모든 edge에 대해 위의 식을 적용한다.
    2. 1번단계를 N-1회 반복한다.

  * 시간 복잡도 : O(|V||E|)

* Floyd-WarShall Algorithm

  * ```
    dists[i][j] = min(dists[i][j], dists[i][k] + dists[k][j])
    ```

  * 플로이드-와샬 알고리즘의 키워드는 경유점이다. i에서 j로의 최단 경로 중에 노드k를 경유하거나, 경유하지 않거나 두 경우의 수 만 고려하는 방법이다. 



#### 위상정렬 (Topological Sort)

어떤 일을 하는 순서를 찾는 알고리즘. 방향 그래프에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것이다.

* 특징
  * 하나의 방향그래프에는 여러 위상정렬이 가능하다.
  * 위상정렬의 과정에서 선택되는 정점의 순서를 위상순서(Toplogical Order)라 한다.
  * 위상 정렬의 과정에서 그래프에 남아 있는 정점중에 진입 차수가 0인 정점이 없다면, 위상 정렬 알고리즘은 중단되고 이러한 그래프로 표현된 문제는 실행이 불가능한 문제가 된다.
* 과정
  * 진입차수가 0 인 정점을 선택한다.
    * 진입차수가 0인 정점중에 무엇을 선택해도 무방하다.
    * 초기에 간선의 수가 0 인 모든 정점을 큐에 삽입
  * 선택된 정점과 여기에 부속된 모든 간선을 삭제한다.
    * 선택된 정점을 큐에서 삭제한다.
    * 선택된 정점에서 부속된 모든 간선에 대해 간선의 수를 감소시킨다.
  * 위의 과정을 반복해서 모든 정점이 선택 후 삭제되면 알고리즘을 종료한다.



## Reference

* https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html
* https://shnoh.tistory.com/15
* https://gmlwjd9405.github.io/2018/08/27/algorithm-topological-sort.html