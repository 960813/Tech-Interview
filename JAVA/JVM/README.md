# JVM(Java Virtual Machine)

## Java의 특징

기본적으로 자바프로그램들은 JVM위에서 동작한다. JVM위에서 동작하기 위해서는 자바 바이트 코드가 필요하다. 이 자바 바이트코드는 개발자에 의해서 작성된 자바 소스코드(.java)를 자바컴파일러(javac)로 변환된 코드(.class)를 말한다. 

### 자바 프로그램의 특징

1. JVM은 Bytecode를 구동하고 있는 OS에 맞추어 BinaryCode로 해석(Interpret)한다. 그러므로 JAVA 프로그램은 OS에 독립적이다. 
2. Bytecode는 클래스 단위(.class)로 생성되므로, 프로그램의 수정이 일어나더라도 전체 소스코드를 다시 컴파일할 필요가 없다.
3. 프로그램이 실행되는 도중에도 JVM은 OS로부터 메모리를 할당받아 스스로 관리한다. 대표적으로 GC(Garbage Collection)이 있다.



> 추가적으로 **객체지향언어는 왜 유지보수가 용이한가?**
>
> 객체지향 프로그램은 기존의 기능을 수정하거나 새로운 기능을 추가하기 용이한데. 기존 기능을 수정시 함수를 새롭게 바꾸더라도 캡슐화와 그 함수의 세부정보가 은폐되어있어 **주변에 미치는 영향을 최소화** 한다. 새로운 객체의 종류를 추가 시에는 상속을 통하여 기존의 기능을 활용하고 존재하지 않은 새로운 속성만 추가하면 되므로 매우 **경제적**이다.



## JVM이란? 

Java Virtual Machine, 자바 가상머신의 약자를 따서 줄여 부르는 용어이다. (가상머신 : 프로그램을 실행하기위해 물리적 머신과 유사한 머신을 소프트웨어로 구현한 것).

JVM의 역할은 자바 어플리케이션을 클래스 로더를 통해 읽어들여 자바 API와 함께 실행하는 것이다.  그리고 JVM은 JAVA와 **OS 사이에서 중개자 역할을 수행**하여 **JAVA가 OS에 구애받지 않고 재사용을 가능하게 해준다**.



## JVM의 기능

1. JAVA가 OS에 상관없이 동작할 수 있도록 중계자 역할을 한다.
2. GC(Garabage Collection)등의 기능을 제공한다.



## JVM의 용도

1. 자바 프로그램이 어느 기기, 또는 어느 운영체제 상에서도 실행될 수 있게 하는 것
2. 프로그램 메모리를 관리하고 최적화하는 것



## JVM의 구성

### Class Loader(클래스 로더)

JVM내로 클래스(.class파일)를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈이다.  Runtime 시에 동적으로 클래스를 로드한다. jar파일 내 저장된 클래스들을 JVM 위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제한다.  

### Execution Engine(실행엔진)

클래스 로더에서 분석된 **클래스 파일의 데이터를 저장**하고 **실행 도중에 필요한 데이터를 저장**하고 **실행 도중에 필요한 데이터를 저장**한다. 메모리를 효율적으로 관리하기 위해 크게 5개의 영역(스태틱, 힙, PC 레지스터, 네이티브 메서드 스택)으로 구분하며, 간단히 메모리 영역이라고 부른다.

### Interpreter(인터프리터)

실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행한다. 하지만 이 방식은 인터프리터 언어의 단점을 그대로 가지고 있다. 한 줄 씩 수행하기 때문에 느리다는 것이다.



### Garbage collector

GC의 기능도 수행한다.

자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했었다. 자바에서는 JVM이 프로그램 메모리를 관리한다. JVM은 가비지 컬렉션이란 프로세스를 통해 메모리를 관리하며, 이 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거한다. 가비지 컬렉션은 실행 중인 JVM 내부에서 일어난다.

초창기에, 자바는 C++만큼 "메탈에 가깝지 않아 C++처럼 빠르지 않다"는 면에서 많은 비평을 받았다. 특히 가비지 컬렉션 프로세스가 논쟁이 되었다. 그 이후, 가비지 컬렉션을 위해 다양한 알고리즘과 접근방식이 제안되고 사용되었다. 일관성 있는 개발과 최적화를 통해 가비지 컬랙션은 크게 개선되었다.



## JVM의 구동과정

![image](https://user-images.githubusercontent.com/36303777/78585427-d303c300-7874-11ea-8655-fdbca5ca95cb.png)

그림 출처 : https://preamtree.tistory.com/2



## 컴파일러와 인터프리터

컴파일러, 인터프리터 둘 다 C나 자바같은 고레벨 언어로 작성된 프로그래밍 언어를 기계어로 변환하는 것은 맞으나 그 과정에 있어서 차이를 보인다. 컴파일러는 전체소스코드를 보고 명령어를 수집하고 재구성하는 반면 인터프리터는 소스코드의 각 행을 연속적으로 분석하며 실행한다.



## 인터프리터의 특성

1. 컴파일러는 소스코드 전체를 한 번 훑고 컴퓨터 프로세서가 실행 할 수 있도록 바로 기계어로 변환한다. **인터프리터는 고레벨 언어를 중간 코드로 변환하고 이를 각 행마다 실행**한다. 이 중간 코드는 다른프로그램에 의해 실행된다.
2. 일반적으로 컴파일러가 각 행마다 실행하는 특성을 가진 인터프리터보다는 실행시간이 빠르다.`(실행시간 : 컴파일러 < 인터프리터(더느림))`
3. 컴파일러는 전체 소스코드를 변환 한 뒤 에러를 보고하지만 인터프리터는 각 행마다 실행하는 도중 에러가 보고되면 이후 작성된 코드를 살펴보지 않는다. 이는 보안적인 관점에서 도움이 된다.
4. 인터프리터 언어 ` ex) 파이썬 컴파일 언어 ex) c c++ `



## 자바의 컴파일러와 인터프리터

- 자바 컴파일러는 .java 파일을 javac(java compiler)가 바이트코드로 쓰여진 .class 파일로 변환한다. 바이트코드는 JVM을 위한 언어

- 자바 인터프리터는 자바 컴파일러에 의해 변환된 클래스파일내의 바이트코드를 특정 환경의 기계에서 실행될 수 있도록 변환한다.

  ### 왜자바는 컴파일과 인터프리트를 병행하는가?

  - 컴파일러의 경우 프로그램이 작성된 기계상에서 실행할 때 매우 효율적.
  - 하지만 인터프리터의 경우는 플랫폼에 종속 되지 않는다.
  - 자바 바이트코드는 컴퓨터와 프로그램 사이에 별도의 버퍼 역할을 한다.(보안적 장점)



Reference 

* https://asfirstalways.tistory.com/158
* https://minwan1.github.io/2018/06/06/2018-06-06-Java,JVM/
* https://sesok808.tistory.com/32
* https://preamtree.tistory.com/2
* http://www.itworld.co.kr/news/110837

