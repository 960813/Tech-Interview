# Array vs Linked List

> 둘다 데이터의 저장방법 들이다.

## 배열(Array)

1. 배열은 데이터를 논리적 순서에 따라 순차적으로 데이터를 입력하며, 물리적 주소 또한 **순차적**이다.
2. 인덱스를 가지고 있어서 원하는 데이터를 한번에 접근이 가능하기 때문에 **데이터 접근 속도가 매우 빠르다**.
3. 배열은 **데이터의 삽입/삭제에는 취약**하다. 배열 특성상 데이터 삽입/삭제가 이루어지면 삽입/삭제가 이루어진 위치의 다음부터 모든 데이터의 위치를 변경해야 하기 때문이다. 
   * 이말은 중간에 삽입한다면 한칸씩 다밀어야되고, 다차면 새롭게 영역을 할당해야되서.



## 연결리스트(Linked List)

> 각 노드가 데이터와 포인터를 가지고 한 줄로 연결시키면서 자료를 저장하는 자료구조

1. 데이터를 논리적 순서에 따라 데이터를 입력한다. 하지만 물리적인 주소는 **순차적**이지 않다.
2. 인덱스를 가지고 있는 배열과는 달리 연결리스트는 인덱스 대신 현재 위치의 **이전 및 다음 위치를 기억**하고 있다.
3. 한번에 데이터 접근이 불가능하다. 연결리스트는 최소 한번은 리스트를 순회하여야 하므로 **O(n)** 에 데이터에 접근한다. 
4. 삽입과 삭제는 연결리스트의 경우 유리하다. 어디에 넣든 데이터를 미루는 등에 추과적인 시간이 소요되지 않는다. 
5. 연결리스트의 구현방법은 2가지이다.
   1. 배열을 이용하는 방법
   2. 구조체와 포인터를 이용하는 방법.



## **면접 예상 질문**

1. 메모리 제한 상황에서 연결리스트 구현

   배열을 이용하여 구현

2. 삽입/삭제가 자주 발생하면 연결리스트 vs 배열 중 어떤 것을 사용?

   연결리스트

3. 데이터 탐색은 연결리스트 vs 배열 중 어떤게 더 빠른가

   배열. 배열은 index를 통해 리얼 타임으로 접근이 가능하고 연결리스트는 반드시 순차적으로 접근을 해야하므로 O(n)이 걸린다.

4. 포인터? 

   & : 메모리 공간 주소를 가리키는 변수

   *: 주소에 있는 값

   ~~~C++
   num = 15;
   p = &num
   (*p == 15) : true
   ~~~

5. 연결리스트에서 루프의 존재를 확인하는 방법

   (1)  visited 이용

   (2)  두개의 포인터 이용해서 탐색. 한개는 2칸 움직이고 다른 하나는 1칸씩 움직여서 겹치면 루프 존재

6. 단일 연결 리스트가 주어졌을 때 리스트의 맨 뒤에서 m번째 원소를 찾아내는 방법?

   (1)  순차적으로 찾는 방법

   ​	head에서 tail까지 리스트를 순회해서 전체 리스트를 체크

   ​	head에서 전체 길이를 L이라 했을 때 L-m번째 노드를 찾으면 됨

   ​	문제점 : 최악의 케이스가 O(n^2)

   (2) 포인터 두개 사용

   ​	p_start와 p_follow를 만들어서 p_start를 m만큼 이동

   ​	p_start를 m만큼 이동하면 남은 이동수는 L-m의 길이를 가지게 됨

   ​	p_start의 남은 L-m만큼 p_follow를 이동하면됨

   ​	항상 O(n)의 알고리즘으로 해결할 수 있음

   

Reference

* https://makefortune2.tistory.com/191
* https://dalkomit.tistory.com/7
* https://hmjo.tistory.com/m/58
* https://manducku.tistory.com/45