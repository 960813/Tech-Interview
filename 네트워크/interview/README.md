# 네트워크 면접 질문

### Q. OSI 7 Layer와 각 계층에 대한 설명을 해보아라

- OSI 7 Layer 란 통신 접속에서 완료까지의 과정을 7단계로 정의한 국제 통신 표준 규약으로 다음과 같이 분류된다.
- 물리계층 : 전송하는데 필요한 기능을 제공. 장비로는 통신 케이블, 허브가 존재한다.
- 데이터링크계층 : 송/수신을 확인. MAC Address를 가지고 통신. 장비로는 브릿지와 스위치가 존재한다.
- 네트워크계층 : 패킷을 네트워크 간의 IP를 통하여 데이터를 전달, 장비로는 라우팅이 존재한다.
- 전송계층 : 두 호스트 시스템으로부터 발생하는 데이터의 흐름을 제공한다.
- 세션계층 : 통신 시스템 사용자간의 연결을 유지 및 설정한다.
- 표현계층 : 세션 계층 간의 주고받는 인터페이스를 일관성 있게 제공한다.
- 응용계층 : 사용자가 네트워크에 접근할 수 있도록 서비스를 제공한다.

* 3계층도 오류제어? [IMCP](https://m.blog.naver.com/PostView.nhn?blogId=rbdi3222&logNo=220602423771&proxyReferer=https:%2F%2Fwww.google.com%2F)

### Q. TCP/IP 프로토콜 스택 4계층으로 구분짓고 설명하라

- LINK 계층
  - 물리적인 영역의 표준화에 대한 결과. 가장 기본이 되는 영역으로 LAN, WAN, MAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역.
- IP 계층
  - 경로검색을 해주는 계층. IP 자체는 비연결지향적이며 신뢰할 수 없는 프로토콜이다. 데이터를 전송할 때마다 거쳐야 할 경로를 선택해주지만, 그 경로는 일정치 않다. 특히 데이터 전송 도중에 경로상에 문제가 발생하면 다른 경로를 선택해 주는데, 이 과정에서 데이터가 손실되거나 오류가 발생하는 등의 문제가 발생한다고 해서 이를 해결해주지 않는다. 즉, 오류발생에 대한 대비가 되어있지 않은 프로토콜이다.
- TCP/UDP(전송) 계층
  - 데이터의 실제 송수신을 담당한다. UDP는 TCP에 비해 상대적으로 간단하며, TCP는 신뢰성 있는 데이터의 전송을 담당한다. 그런데 TCP가 데이터를 보낼 때 기반이 되는 프로토콜이 IP이다. 앞서 말했듯이 IP 계층은 문제가 발생한다면 해결해주지 않는 신뢰되지 않은 프로토콜이다. 그 문제를 해결해 주는 것이 TCP. 데이터가 순서에 맞게 올바르게 전송이 갔는지 확인을 해주며 대화를 주고받는다. 확인절차를 걸쳐서 신뢰성 없는 IP에 신뢰성을 부여한 프로토콜이라 생각하면 됨.
- APPLICATION 계층
  - 이러한 서버와 클라이언트를 만드는 과정에서 프로그램의 성격에 따라 데이터 송수신에 대한 약속(규칙)들이 정해지기 마련인데, 이를 가리켜 Aplication 프로토콜이라한다.

### Q. TCP에 대해 설명하시오

- TCP 서버의 함수호출 순서 : socket() 소켓생성 -> bind() 소켓 주소할당 -> listen() 연결요청 대기상태 -> accept() 연결허용 -> read()/write() 데이터 송수신 -> close() 연결종료
- TCP 클라이언트의 함수호출 순서 : socket() 소켓생성 -> connect() 연결요청 -> read()/write() 데이터 송수신 -> close() 연결종료
- 서버와 클라이언트의 차이점은 ‘연결요청’이라는 과정이다. 이는 클라이언트 소켓을 생성한 후에 서버로 연결을 요청하는 과정. 서버는 listen()를 호출한 이후부터 연결요청 대기 큐를 만들어 놓는다. 따라서 그 이후부터 클라이언트는 연결요청을 할 수 있다. 이 때, 서버가 바로 accept()를 호출할 수 있는데 이때는, 연결되기 전까지 호출된 위치에서 블로킹 상태에 놓이게 된다.
- 3-way handshaking : TCP 소켓은 연결설정 과정에서 총 세번의 대화를 주고 받는다.
  - SYN :: Synchronize Sequence Number 연결 요청 플래그
  - ACK :: Acknoledgement 응답
  - 클라이언트는 서버에 접속을 요청하는 SYN(M) 패킷을 보낸다.
  - 서버는 클라이언트의 요청인 SYN(M)을 받고 클라이언트에게 요청을 수락한다는 ACK(M+1)와 SYN(N)이 설정된 패킷을 발송한다.
  - 클라이언트는 서버의 수락 응답인 ACK(M+1)와 SYN(N) 패킷을 받고 ACK(N+1)를 서버로 보내면 연결이 성립된다.
  - 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송한다.
  - 서버는 클라이언트의 요청(FIN)을 받고 알겠다는 확인 메세지로 ACK를 보낸다. 그리고나서는 데이터를 모두 보낼 때까지 잠깐 TIME_OUT이 된다.
  - 데이터를 모두 보내고 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송한다.
  - 클라이언트는 FIN 메세지를 확인했다는 메세지(ACK)를 보낸다.
  - 클라이언트의 ACK 메세지를 받은 서버는 소켓 연결을 Close한다.
  - 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거친다. (TIME_WAIT)

### Q. UDP에 대해 설명하시오

- UDP는 TCP의 대안이며, IP와 함께 쓰일 때에는 UDP/IP라고 표현하기도 한다.
- TCP와 마찬가지로 실제 데이터 단위를 받기위해 IP를 사용한다. 그러나 TCP와 달리, 메세지를 패킷으로 나누고, 반대편에서 재조립하는 등의 서비스를 제공하지 않는다. 즉, 여러 컴퓨터를 거치지 않고 데이터를 주고 받을 컴퓨터끼리 직접 연결하고자 할때 UDP를 사용한다.
- UDP를 사용해서 목적지(IP)로 메세지를 보낼 수 있고, 컴퓨터를 거쳐서 목적지까지 도달할 수도 있다. 허나 도착하지 않을 수도 있다. 정보를 받는 컴퓨터에서는 포트를 열어두고 패킷이 올 때까지 기다리며 데이터가 온다면 모두 다 받아들인다. 패킷이 도착했을 때 출발지에 대한 정보(IP, PORT)를 알 수 있다.
- UDP는 이러한 특성 때문에 안정적이지 않은 프로토콜이다. 하지만 TCP에 비해서 속도가 빠른편이기에 데이터의 유실이 일어나도 큰 상관이 없는 스트리밍이나 화면전송에 사용된다.

### Q. Multi-Thread 서버에 대해 설명하시오

- 듣기 소켓을 통해서 새로운 클라이언트가 들어오면 fork(:2) 함수를 이용해서 자식 프로세스를 만드는 대신에, pthread_create(:3) 함수를 이용해서 새로운 스레드를 만드는 것이다. 이 스레드는 문맥을 포함한 코드 조각으로 듣기 소켓의 소켓 지정 번호를 매개 변수로 받아들일 수 있다. 이 듣기 소켓을 이용해서 클라이언트를 처리하는 식이다.
- 핵심은 서버 프로그램이 듣기 소켓과 연결 소켓이 분리되어 있는데, 듣기 소켓에 클라이언트 연결이 들어와서 연결 소켓이 만들어 지면, 스레드를 만들어 클라이언트 요청을 처리하는데 있다. (대리자)
- 스레드는 코드 조각이므로 프로세스를 복사하는 멀티 프로세스 방식보다 좀 더 작고 빠르게 작동하는 프로그램을 만들 수 있다. 반면 독립된 프로세스 단위로 구동되지 않기 때문에, 디버깅이 힘들다는 단점이 있다. 또한 하나의 스레드에 생긴 문제가 전체 프로세스에 문제를 줄 수 있다는 문제점도 있다.

### Q. IOCP에 대해 설명하시오

- IOCP는 어떤 I/O 핸들에 대해서, 블록 되지 않게 비동기 IO작업 함으로 프로그램 대기시간을 줄이는 목적으로 사용된다. 우선 Overlapped IO의 개념이 기반이 된다. IOCP는 이런 Overlapped IO가 실행이 되고 알려주는 방법에 대한 것이다.

- 동기화 오브젝트 세마포어의 특성과 큐(Queue)를 가진 커널 오브젝트이다. 스레드상에서 사용되며 대부분 여러 스레드, 즉 멀티스레드 상에서 사용된다. 큐를 자체적으로 운영하는 특징때문에 스레드 풀링에 적합하다.

- 동기화와 동시에 큐를 통한 데이터전달(완료알림) IOCP는

  스레드 풀링

  을 위한 것이라 할수 있다.

  - 여기서 풀링이란, 여러 스레드를 생성하여 대기시켜놓고 필요할 때 가져다가 사용 후 다시 반납하는 과정이다. 스레드 생성과 파괴에는 상당한오버헤드가 있기 때문.

- 장점

  - 사용자가 설정한 버퍼만을 사용하기 때문에 더 효율적으로 작동한다. 기존에는 OS버퍼, 사용자 버퍼로 따로 분리되는 개념이었다.
  - IO요청에 대해서 효율적으로 접근한다. 디스크 IO의 경우 디스크에 접근을 효율적으로 한다. 순서대로가 아닌 효율적인 순서에 따라 접근하기도 함. 즉, 커널레벨에서는 모든 IO를 비동기적으로 처리한다.

- 주의사항

  - 소켓생성(WSASocket)을 할 때 마지막에 반드시 WSA_FLAG_OVERLAPPED를 넣어줘야함
  - WSASend, WSARecv 사용 할 때 Overlapped구조체를 넣어줄것

### Q. 브라우저 주소창에 http://www.test.com 입력 후 엔터를 눌렀을 때 부터 페이지가 렌더링되는 과정을 상세히 설명하세요.

A.

1. local DNS 서버에게 www.test.com에 해당하는 ip주소가 있는지 물어본다. 있다면 바로 해당 ip로 받아온다.
2. local DNS 서버에 없다면 루트 DNS 서버에 물어본다. 있다면 바로 해당 ip로 받아온다.
3. 루트 DNS 서버에 없다면 .com 을 관리하는 DNS 서버에 물어본다. 있다면 바로 해당 ip를 받아온다.
4. .com 을 관리하는 DNS 서버에 없다면, test.com을 관리하는 DNS 서버에 물어본다. 있다면 바로 해당 ip를 받아온다.
5. 목적지의 ip를 알게되었으니 TCP 통신을 통해 소켓을 개방한다.
6. HTTP 프로토콜로 요청한다.
7. 만약 라우팅 중 프록시 서버를 만난다면 웹 캐시에 저장된 정보를 response 받는다.
8. 프록시 서버를 만나지 못해 www.test.com을 서빙하는 서버까지 간다면 서버에서 요청에 맞는 데이터를 response로 전송한다.
9. 브라우져의 loader가 해당 response를 다운로드할지 말지 결정을한다.
10. 브라우져의 웹 엔진이 다운로드한 .html 파일을 파싱하여 DOM 트리를 결정한다.
11. .html 파싱중 script 태그를 만나면 파싱을 중단하는 것이 원칙(지연 가능).
12. script 태그에 있는 자원을 다운로드 하여 처리가 완료되면 다시 파싱을 재개한다.
13. CSS parser가 역시 .css 파일을 파싱하여 스타일 규칙을 DOM 트리에 추가하여 렌더 트리를 만든다.
14. 이 렌더트리를 기반으로 브라우져의 크기에 따라 각 노드들의 크기를 결정한다.
15. 페인트한다 : 렌더링 엔진이 배치를 시작한다.

### Q. TCP 통신을 조금 더 자세히 설명해보세요.

A. 트랜스포트 계층에서 사용되는 프로토콜로 3-hand-shaking을 기반으로 신뢰할 수 있는 데이터를 보내는 것이 가장 큰 특징이다. 3-hand-shaking은

1. client -> server : SYC
2. server -> client : ACK+SYC
3. client -> server : ACK

를 보내고 받음으로 서버와 클라이언트간의 연결성을 확립하는 것 이다.

### Q. TCP 통신 시 2번 단계의 클라이언트가 서버가 보낸 ACK+SYC를 받지 못한다면 어떻게 되나요?

A. 1번단계에서 클라이언트는 서버로 SYC를 보내고 시간을 잰다. timeout이 되기전 까지 ACK+SYC가 오지 않는다면 다시 서버로 SYC를 보내고 ACK+SYC 수신을 대기한다.

### Q. 만약 https://www.test.com 이라면 어떻게 동작하는가?

A. 5번 단계에서 3-hand-shaking에 몇가지가 더 추가된다.

1. client -> server : SSL정보 및 암호화방식, 무작위 바이트 문자열(A)
2. server -> client : 인증서, 무작위 바이트 문자열(B)
3. client가 CA에 인증서 목록에 있는지 확인 후 있다면 공개키를 받는다.
4. client -> server : 무작위 바이트 문자열 A와 B를 조합해서 확보한 공개키로 암호화한 데이터
5. server에서 비밀키로 받은 무작위 바이트 문자열 조합을 복호화한다. 이 조합을 가지고 session key를 만든다.
6. 해당 session key를 가지고 암호화한 데이터를 주고 받는다.

### Q. 프록시 서버 기능에 대해 설명해보시오.

A. 클라이언트가 프록시 서버를 통해서 다른 네트워크 서비스에 간접적으로 접근을 할 수 있게 하는 것을 말한다. 프록시 서버는 요청된 내용들을 캐시에 저장을하고 다음에 같은 요청이 들어온다면 캐시에 저장된 정보를 제공함으로써 전송시간을 줄일 수 있다.

### Q. 말씀하신 기능대로 라면 프록시 서버 캐시에 저장된 내용을 계속해서 다운로드 받게될텐데 페이지가 바뀌는 업데이트를 했거나, 값이 계속해서 바뀐다면 어떻게 처리하나요?

A. 실제 서버에서 응답할 때 캐시 만료기한을 설정해두면 됩니다. 프록시서버라도 최초로 받는 요청에는 실제 서버로 요청을 보내야하기 때문에 그 때 실제 서버에서 캐시 만료기한을 설정해서 프록시 서버로 보내면 됩니다. 그러면 프록시서버로 사용자가 요청을 했을 때 요청한 시각이 프록시에서 다운로드 받은 시간에서 만료기한 이내이면 프록시에서 다운로드를 할 것이고 그렇지 않다면, 다시 실제 서버로 요청을 하게 될 것입니다.

저 역시 배포시에 위와 같은 문제를 겪었는데 배포때를 제외하고는 모두 캐시되는게 좋다고 판단하여 Vue.js로 빌드할 경우 index.html에서 요구하는 css, js파일들의 파일명을 바꾸어서 해결했었습니다.

### Q. HTTP와 프로토콜에 대해 설명하세요.

A. Hyper Text Transfer Protocol의 약자로 인터넷에서 데이터를 주고 받을 수 있는 프로토콜입니다. 프로토콜은 컴퓨터나 다른 원거리 장비들 간의 메시지를 주고 받기 위해 지켜야하는 일종의 규약이다.

### Q. HTTP REQUEST 방식 중 GET과 POST의 차이에 대해 설명해보세요.

A. GET방식은 서버에 데이터를 전달하기 위해서는 url query로 밖에 전달을 할 수가 없어 보안에 취약하다. 그래서 GET은 데이터를 받는 용도로 사용하는데 적합하다. 반면에 POST방식은 서버로 전달하고자 하는 데이터를 header에 넣어서 전달을 한다. 헤더를 직접 열어보지 않는 이상 확인할 수 없다. 또한 HTTPS을 사용할 경우 해당 내용이 암호화되기 때문에 더더욱 안전하기 때문에 POST방식은 DB의 내용을 갱신해야하거나 서버로 데이터를 전달해야할 때 쓰는 것이 적합하다.

### Q. GET, POST를 제외하고 다른 방식들 중 아는게 있나?

A. PUT, DELETE, FETCH 말고도 상당히 많은 것으로 알고있다. PUT은 데이터 갱신용, DELETE는 데이터 삭제용으로 사용해본적 있지만, FETCH 포함하여 나머지는 사용해 본적은 없다.

### Q. HTTP는 비연결성 프로토콜이냐? 연결성 프로토콜이냐?

A. 비연결성 프로토콜입니다. REQUEST에 대한 RESPONSE만 전달이 되고 연결을 유지하지 않습니다.

### Q. 왜 비연결성인가?

A. 초기 HTTP가 고안됬을 때는 뜻을 보면 알 수 있듯이 Hyper Text를 주고 받기 위해 만들어져서 따로 연결을 할 필요가 없기 때문으로 알고 있습니다.

### Q. 현대 웹 에서는 비연결성을 해결하기 위해 어떻게 하는가?

A. 전통적으로 Cookie와 Session을 많이 이용한다. Cookie에 클라이언트에 대한 정보를 저장해뒀다가 사용하거나 Session을 등록해서 유지하는 방식으로 많이쓴다. HTML5에서 제공하는 Session Storage나 Local Storage도 사용할 수 있다. 세션 스토리지는 세션이 유지되고 있을 때 까지는 브라우저 내부 스토리지에 저장을 하고 세션이 끊키면 자동으로 없어진다. 로컬 스토리지 같은 경우는 사용자나 프론트엔드 내부적으로 삭제를 하지 않는 이상 영구적으로 저장된다.

### Q. Cookie, Session, Session Storage, Local Storage 중 어떤 것이 가장 효율적인가요?

A. 정답은 없다고 생각한다. 프로젝트의 목적성과 타겟에 맞게끔 개발자가 직접 정해야한다. 모든 브라우져에서 지원되어야 하는 호환성이 굉장히 중요한 e커머스 경우에는 Session Storage나 Local Storage를 쓰기에는 무리가 있다.

### Q. Front-End 개발시 호환성 체크는 어떻게 하나요?

A. 저 같은 경우는 stack browser를 사용해서 체크하고, 많이 사용되는 IE같은 경우에는 로컬으로 접속해서 부가적으로 확인을 재차한다. IOS에 있는 브라우져는 로컬에 XCODE 시뮬레이터로 아이폰 브라우져를 체크하고 안드로이드는 안스에 있는 에뮬레이터로 주로 사용되는 기종들만 체크했다.

### Q. CORS문제는 겪어본적 있는가?

### Q. 자바스크립트에서 HTTP request를 동기로 호출하고 값을 처리하면 발생하는 문제점이 무엇인가?

A. Request에 대한 Response에 받는 응답시간이 길어질 수도 있기 때문에 절차 지향적으로 짜놓은 코드가 제대로 동작하지 않을 수도 있다.

### Q. 위와 같은 문제를 해결하기 위한 방법은 무엇이 있는가?

A. CallBack 함수를 만들어 호출하면 해당 REQUEST에 대한 응답이 온 후에 이후에 그값을 가지고 다시 다른 함수를 실행한다.

### Q. 콜백함수의 문제점이 무엇인가? 그리고 거기에 대한 해결책은?

A. 콜백함수를 이용하여 비동기처리를 많이 하게되면 콜백헬이라 불리는 가독성이 엄청나게 떨어지는 코드를 만들게 된다. 이러한 가독성저하는 유지보수에 문제를 야기할 수 있으므로 Promise 나 Async/Await을 사용하면 해결할 수 있다. Promise에서는 요청 후 비동기 처리하는 부분은 then절에 추가하면 되고 Async/Await는 Await이 then절과 같은 역할을 한다.

### Q. Promise vs Async/Await 당신의 선택은?

A. ES7에 Async/Await 문법이 추가되었다고 들었다. 그만큼 많은 사람들이 쓴다고 비교했을 때 장점으로 치면 try & catch를 이용해서 예외처리를 할 수 있고, 간단한 비동기 처리 경우에는 확실히 가독성이 뛰어나다는 점이였다. 그러나 나는 Promise를 선호하는 편이다. Async/Await가 Promise로 구성되있다는 사실을 접하게 되었고 Promise를 잘 모르는 상태로 Async/Await를 쓰면 알 수 없는 오류에 빠지기 쉽다는 글을 보았다. Promise로 다양한 비동기 처리를 경험해보고 다양한 오류를 만나기 전까지는 Promise로 더 공부를 하는게 나에게 맞는다고 생각한다.

### Q. OAUTH?

OAuth는 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는, 접근 위임을 위한 개방형 표준이다

### Q. Callback 의 문제

### Q. Promise, Async/Await

[https://medium.com/@constell99/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-async-await-%EA%B0%80-promises%EB%A5%BC-%EC%82%AC%EB%9D%BC%EC%A7%80%EA%B2%8C-%EB%A7%8C%EB%93%A4-%EC%88%98-%EC%9E%88%EB%8A%94-6%EA%B0%80%EC%A7%80-%EC%9D%B4%EC%9C%A0-c5fe0add656c](https://medium.com/@constell99/자바스크립트의-async-await-가-promises를-사라지게-만들-수-있는-6가지-이유-c5fe0add656c)

[https://medium.com/@kiwanjung/%EB%B2%88%EC%97%AD-async-await-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90-promise%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-955dbac2c4a4](https://medium.com/@kiwanjung/번역-async-await-를-사용하기-전에-promise를-이해하기-955dbac2c4a4)

### References

- https://91ms.tistory.com/5
-
